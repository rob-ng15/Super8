unit CPU6502(
    output  uint16  out_address,
    output  uint24  out_data,
    input   uint24  in_data,

    output  uint3   req_mask,
    output  uint1   req_read,
    output  uint1   req_write,
    input   uint1   mem_busy,

    input   uint1   RUN,
    input   uint1   RESET
) <reginputs> {

    // REGISTERS
    //  00 A
    //  01 X
    //  02 Y
    //  03 SP
    //  04 SR

    uint16  PC = uninitialised; uint16  PCnext <:: PC + MCODE.i_length; uint16  PCp1 <:: PC + 1;                                // PC
    uint8   REGS[3] = { 0, 0, 0 };                                                                                              // { A, X, Y }
    uint8   SP = uninitialised;                                                                                                 // STACK POINTER
    uint8   SPm1 <:: SP - 1; uint8   SPm2 <:: SP - 2; uint8   SPm3 <:: SP - 3;
    uint8   SPp1 <:: SP + 1; uint8   SPp2 <:: SP + 2; uint8   SPp3 <:: SP + 3;

    uint16  ADDR = uninitialised;
    uint8   VALUE_8 = uninitialised;
    uint1   JUMPBRANCH = uninitialised;
    uint9   RESULT = uninitialised;                                                                                             // RESULT, 1 EXTRA BIT FOR UNDERFLOW / OVERFLOW
    uint3   REGISTER = uninitialised;

    microcode_6502 MCODE(
        fetch <: in_data,
        X <: REGS[1],
        Y <: REGS[2],
        PC <: PCnext
    );
    sr_6502 SR();

    uint24  cycles = 0; uint24  start_cycle = uninitialised;                                                                    // DEBUG PRINT OUT CYCLES PER INSTRUCTION
    req_read := 0; req_write := 0; MCODE.latch := 0; SR.update := 0; cycles := cycles + 1;                                                                        // HOLD MEMORY FLAGS AT 0

    algorithm <autorun> {
        out_address = 16hFFFC; req_read = 1; while( mem_busy ) {} PC = in_data[0,16];                                                // FETCH RESET PC ADDRESS
        out_address = in_data[0,16]; req_read = 1;                                                                                         // FETCH FIRST INSTRUCTION

        while(1) {
            while( RUN ) {
                JUMPBRANCH = 0; SR.mask = 0; start_cycle = cycles;                                              // CLEAR JUMPBRANCH FLAG, FLAGS MASK
                while( mem_busy ) {} MCODE.latch = 1; ++: ++:                                                                                         // WAIT FOR FETCH TO FINISH

                __write("( PC = %h %h ) 6502 = %h mcode %h amode %h ind %b actions %b",PC,in_data,in_data[0,8],MCODE.i_mcode,MCODE.i_amode,MCODE.i_indirect,MCODE.i_actions);

                if( MCODE.i_indirect ) {
                    out_address = MCODE.i_ea; req_read = 1; while( mem_busy ) {}                                                // IF INDIRECT FETCH EFFECTIVE ADDRESS
                }
                ADDR = ( MCODE.i_indirect ? in_data[0,16] : MCODE.i_ea ) + MCODE.i_ea_offset;

                if( MCODE.i_actions[0,1] & ~MCODE.i_immediate ) {                                                                                            // FETCH 8 BIT VALUE_8 FROM MEMORY
                    out_address = ADDR; req_read = 1; while( mem_busy ) {} VALUE_8 = in_data[0,8];
                } else {
                    VALUE_8 = MCODE.value_8;
                }

                __display("[EA %h V8 %h]",ADDR,VALUE_8);
                if( MCODE.i_actions[2,1] ) {                                                                                            // MULTI-CYCLE INSTRUCTIONS
                    switch( MCODE.i_mcode[4,4] ) {
                        case 4h5: {                                                                                                 // JSR, RTS, RTI
                            if( MCODE.i_mcode[3,1] ) {
                                out_address = { 1b1, SPp1 }; req_read = 1; while( mem_busy ) {}
                                if( MCODE.i_mcode[0,1] ) {                                                                                 // RTI FETCH STATUS REGISTER
                                    SR.mask = 8b11111111; SR.flags = in_data[0,8]; ADDR = in_data[8,16];
                                    SP = SPp3;
                                } else {
                                    ADDR = in_data[0,16];
                                    SP = SPp2;
                                }
                            } else {
                                out_address = { 1b1, SPm1 }; req_mask = 2b11; out_data = PCnext;                                    // JSR, WRITE TO STACK
                                req_write = 1; while( mem_busy ) {}
                                SP = SPm2;
                            }
                            JUMPBRANCH = 1;
                        }
                        case 4h8: {
                            if( MCODE.i_mcode[3,1] ) {
                                out_address = { 1b1, SPp1 }; req_read = 1;                                                      // SETUP PULL
                            } else {
                                out_address = { 1b1, SP }; req_mask = 2b01;                                                     // SETUP PUSH
                                out_data = MCODE.i_mcode[2,1] ? SR.SR : REGS[ MCODE.i_mcode[0,2] ][0,8];
                                req_write = 1;
                            }

                            while( mem_busy ) {}                                                                                // WAIT FOR MEMORY

                            if( MCODE.i_mcode[3,1] ) {                                                                                 // PULL
                                RESULT = in_data[0,8]; REGISTER = MCODE.i_mcode[0,2];                                                  // SET REGISTER RESULT/DESTINATION
                                SR.mask = MCODE.i_mcode[2,1] ? 8b11111111 : 8b10000010;                                                 // SET FLAGS MASK, ALL IF PLP
                                SR.flags = MCODE.i_mcode[2,1] ? in_data[0,8] : { in_data[7,1], 6b00000, ~|in_data[0,8] };              // SET FLAGS NZ
                            }
                            SP = MCODE.i_mcode[3,1] ? SPp1 : SPm1;                                                                     // ADJUST STACK POINTER
                        }
                        default: {}
                    }
                } else {
                    switch( MCODE.i_mcode[4,4] ) {
                        case 4h0: {                                                                                                 // ARITHMETIC
                            switch( MCODE.i_mcode[0,4] ) {
                                case 4h1: {                                                                                         // ADC
                                    RESULT = REGS[0] + VALUE_8 + SR.C;                                                           // A + M + C
                                    SR.mask = 8b11000011;
                                    SR.flags = {
                                                RESULT[7,1],                                                                        // N
                                                ( REGS[0][7,1] ^ VALUE_8[7,1] ) ? 1b0 : RESULT[7,1] ^ VALUE_8[7,1],                 // V, IF SIGNS SAME, SIGN OF RESULT DIFFERENT
                                                4b0000,
                                                ~|RESULT[0,8],                                                                      // Z
                                                RESULT[8,1]                                                                         // C CARRY
                                            };
                                }
                                case 4h2: {                                                                                         // SBC
                                    RESULT = REGS[0] - VALUE_8 - SR.C;                                                           // A - M - C
                                    SR.mask = 8b11000011;
                                    SR.flags = {
                                                RESULT[7,1],                                                                        // N
                                                ( REGS[0][7,1] ^ VALUE_8[7,1] ) ? 1b0 : RESULT[7,1] ^ VALUE_8[7,1],                 // V, IF SIGNS SAME, SIGN OF RESULT DIFFERENT
                                                4b0000,
                                                ~|RESULT[0,8],                                                                      // Z
                                                RESULT[8,1]                                                                         // C BORROW
                                            };
                                }
                                case 4h3: {
                                    RESULT = REGS[0] & VALUE_8;                                                                     // AND
                                    SR.mask = 8b10000010; SR.flags = { RESULT[7,1], 6b00000, ~|RESULT[0,8] };                        // SET NZ FLAGS
                                }
                                case 4h4: {
                                    RESULT = REGS[0] | VALUE_8;                                                                     // OR
                                    SR.mask = 8b10000010; SR.flags = { RESULT[7,1], 6b00000, ~|RESULT[0,8] };                        // SET NZ FLAGS
                                }
                                case 4h5: {
                                    RESULT = REGS[0] ^ VALUE_8;                                                                     // XOR
                                    SR.mask = 8b10000010; SR.flags = { RESULT[7,1], 6b00000, ~|RESULT[0,8] };                        // SET NZ FLAGS
                                }
                                case 4h6: {
                                    RESULT = { VALUE_8[0,7], 1b0 };                                                                 // ASL
                                    SR.mask = 8b10000011; SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], VALUE_8[7,1] };          // SET NZC FLAGS
                                }
                                case 4h7: {
                                    RESULT = { 1b0, VALUE_8[1,7] };                                                                 // LSR
                                    SR.mask = 8b10000011; SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], VALUE_8[0,1] };          // SET NZC FLAGS
                                }
                                case 4h8: {
                                    RESULT = { VALUE_8[0,7], SR.C };                                                             // ROL
                                    SR.mask = 8b10000011; SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], VALUE_8[7,1] };          // SET NZC FLAGS
                                }
                                case 4h9: {
                                    RESULT = { SR.C, VALUE_8[1,7] };                                                             // ROR
                                    SR.mask = 8b10000011; SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], VALUE_8[0,1] };          // SET NZC FLAGS
                                }
                                case 4ha: {                                                                                         // BIT
                                    SR.mask = ( MCODE.i_amode == 4h5 ) ? 8b00000010 : 8b11000010;                                            // ( 65c02 ) IMM MODE ONLY AFFECTS Z FLAG
                                    SR.flags = { VALUE_8[6,2], 4b0000, ~|( VALUE_8 & REGS[0]), 1b0 };                               // SET N = bit 7, V = bit 6, AND Z FLAGS
                                }
                                case 4hb: {                                                                                         // TRB TSB BBRx BBSx RMBx SMBx( 65c02 )
                                    // NEED IMPLEMENTATION
                                }
                                default: {}
                            }
                            REGISTER = 0;
                        }
                        case 4h1: { JUMPBRANCH = ( SR.SR[ MCODE.i_mcode[0,3], 1 ] == MCODE.i_mcode[3,1] ); }                                         // BRANCH, TEST FLAG[ MCODE.i_mcode[0,3] ] == OPCDOE[3,1]
                        case 4h2: { SR.mask = 1 << MCODE.i_mcode[0,3]; SR.flags = MCODE.i_mcode[3,1] << MCODE.i_mcode[0,3]; }                             // SET FLAG[ MCODE.i_mcode[3,1] ] TO MCODE.i_mcode[3,1]
                        case 4h3: {                                                                                                 // COMPARE
                            RESULT = REGS[ MCODE.i_mcode[0,2] ] - VALUE_8;                                                                 // A | X | Y - FETCHED MEMORY VALUE
                            SR.mask = 8b10000011; SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], RESULT[8,1] };                   // SET FLAGS, C IS M > REG ( borrow )
                        }
                        case 4h4: {                                                                                                 // INC/DEC MEMORY, X OR Y ( A is supported for 65c02 )
                            if( MCODE.i_mcode[3,1] ) {
                                RESULT = ( &MCODE.i_mcode[0,2] ? VALUE_8 : REGS[ MCODE.i_mcode[0,2] ] ) + 1;                                      // INC
                            } else {
                                RESULT = ( &MCODE.i_mcode[0,2] ? VALUE_8 : REGS[ MCODE.i_mcode[0,2] ] ) - 1;                                      // DEC
                            }
                            SR.mask = 8b10000010; SR.flags = { RESULT[7,1], 6b00000, ~|RESULT[0,8] };                                // SET NZ FLAGS
                            REGISTER = MCODE.i_mcode[0,2];
                        }
                        case 4h5: {                                                                                                 // JMP
                            JUMPBRANCH = 1;
                        }
                        case 4h6: {
                            RESULT = MCODE.i_mcode[3,1] ? &MCODE.i_mcode[0,4] ? 0 : REGS[ MCODE.i_mcode[0,2] ] : VALUE_8; REGISTER = MCODE.i_mcode[0,2];
                            SR.mask = 8b10000010; SR.flags = { REGS[ MCODE.i_mcode[0,2] ][7,1], 5b00000, ~|REGS[ MCODE.i_mcode[0,2] ][0,8], 1b0 };
                        }
                        case 4h7: {                                                                                                 // ACCUMULATOR SHIFTS/ROTATES
                            switch( MCODE.i_mcode[0,1] ) {
                                case 0: { RESULT = { REGS[0][1,7], MCODE.i_mcode[1,1] ? SR.C : 1b0 }; }                                 // ASL ( push in 0 ), ROL ( push in C )
                                case 1: { RESULT = { MCODE.i_mcode[1,1] ? SR.C : 1b0, REGS[0][0,7] }; }                                 // LSR ( push in 0 ), ROR ( push in C )
                            }
                            SR.mask = 8b10000011;                                                                                    // SET FLAGS MASK, NZC
                            SR.flags = { RESULT[7,1], 5b00000, ~|RESULT[0,8], REGS[0][ MCODE.i_mcode[0,1] ? 0 : 7, 1 ] };                  // SET FLAGS, C IS DROPPED BIT
                        }
                        case 4h9: {                                                                                                 // TRANSFER { 9, fftt } where ff FROM and tt TO
                            RESULT = &MCODE.i_mcode[2,2] ? SP : REGS[ MCODE.i_mcode[2,2] ];                                                       // ==0 A, ==1 X, ==2 Y, ==3 SP
                            SR.mask = &MCODE.i_mcode[2,2] ? 8b00000000 : 8b10000010; SR.flags = { RESULT[7,1], 6b00000, ~|RESULT[0,8] };    // TRANSFER TO SP NO FLAGS, OTHERWISE NZ FLAGS AFFECTED
                            REGISTER = MCODE.i_mcode[0,2];
                        }
                        case 4hA: {                                                                                                 // BRK, NOP
                        }
                        default: {}                                                                                                 // UNDEFINED
                    }
                }

                if( MCODE.i_actions[3,1] ) {                                                                                            // WRITE 8 BIT VALUE_8 TO MEMORY
                    out_address = ADDR; req_mask = 2b01; out_data = RESULT[0,8]; req_write = 1;
                }

                if( MCODE.i_actions[5,1] ) {                                                                                            // COMMIT TO REGISTER
                    if( &REGISTER ) { SP = RESULT[0,8]; } else { REGS[ REGISTER ] = RESULT[0,8]; }
                }

                SR.update = MCODE.i_actions[6,1];                                                                                       // UPDATE SR

                while( mem_busy ) {}                                                                                            // WAIT FOR STORE TO FINISH
                out_address = JUMPBRANCH ? ADDR : PCnext; PC = JUMPBRANCH ? ADDR : PCnext;  req_read = 1;                       // FETCH NEXT INSTRUCTION
                __display("CYCLES = ",cycles - start_cycle);
            }
        }
    }
}

// FLAGS
//  { N V - B D I Z C }
//  07 N NEGATIVE
//  06 V OVERFLOW
//  05
//  04 B BREAK
//  03 D DECIMAL
//  02 I INTERRUPT
//  01 Z ZERO
//  00 C CARRY

unit sr_6502(
    output  uint8   SR,
    output  uint1   C,
    input   uint8   mask,
    input   uint8   flags,
    input   uint1   update
) <reginputs> {
    C := SR[0,1];

    algorithm <autorun> { while(1) {
        if( update ) { SR = ( SR & ~mask ) | ( flags & 8b11011111 ); }                                                          // ENSURE BIT 5 NEVER GETS SET
    } }
}

unit microcode_6502(
    input   uint24  fetch,
    input   uint1   latch,
    input   uint8   X,
    input   uint8   Y,
    input   uint16  PC,
    output  uint8   i_mcode,
    output  uint5   i_amode,
    output  uint7   i_actions,
    output  uint3   i_length,
    output  uint1   i_indirect,
    output  uint1   i_immediate,
    output  uint8   value_8,
    output  uint16  value_16,
    output  uint16  i_ea,
    output  uint8   i_ea_offset,
) <reginputs> {
    // MICROCODE INSTRUCTIONS
    //  00 UNDEFINED

    //  01 ADC                                      add with carry
    //  02 SBC                                      subtract with carry
    //  03 AND                                      and (with accumulator)
    //  04 EOR                                      exclusive or (with accumulator)
    //  05 ORA                                      or (with accumulator)
    //  06 ASL                                      arithmetic shift left
    //  07 LSR                                      logical shift right
    //  08 ROL                                      rotate left
    //  09 ROR                                      rotate right
    //  0A BIT                                      bit test

    //  10 BCC                                      branch on carry clear
    //  18 BCS                                      branch on carry set
    //  19 BEQ                                      branch on equal (zero set)
    //  1F BMI                                      branch on minus (negative set)
    //  11 BNE                                      branch on not equal (zero clear)
    //  17 BPL                                      branch on plus (negative clear)
    //  16 BVC                                      branch on overflow clear
    //  1E BVS                                      branch on overflow set
    //  15 BRA                                      branch always ( 65c02 )

    //  20 CLC                                      clear carry
    //  23 CLD                                      clear decimal
    //  22 CLI                                      clear interrupt disable
    //  26 CLV                                      clear overflow
    //  28 SEC                                      set carry
    //  2B SED                                      set decimal
    //  2A SEI                                      set interrupt disable

    //  30 CMP                                      compare (with accumulator)
    //  31 CPX                                      compare with X
    //  32 CPY                                      compare with Y

    //  40 DEC A                                    decrement A
    //  41 DEX                                      decrement X
    //  42 DEY                                      decrement Y
    //  43 DEC                                      decrement
    //  48 INC A                                    increment A
    //  49 INX                                      increment X
    //  4A INY                                      increment Y
    //  4C INC                                      increment

    //  50 JMP                                      jump
    //  51 JSR                                      jump subroutine
    //  59 RTI                                      return from interrupt
    //  58 RTS                                      return from subroutine

    //  60 LDA                                      load accumulator
    //  61 LDX                                      load X
    //  62 LDY                                      load Y
    //  68 STA                                      store accumulator
    //  69 STX                                      store X
    //  6A STY                                      store Y
    //  6F STZ                                      store 0 ( 65c02 )

    //  70 ASL A                                    arithmetic shift left
    //  71 LSR A                                    logical shift right
    //  72 ROL A                                    rotate left
    //  73 ROR A                                    rotate right

    //  80 PHA                                      push accumulator
    //  81 PHX                                      push X ( 65c02 )
    //  82 PHY                                      push Y ( 65c02 )
    //  84 PHP                                      push processor status (SR)
    //  88 PLA                                      pull accumulator
    //  89 PLX                                      pull X ( 65c02 )
    //  8A PLY                                      pull Y ( 65c02 )
    //  8C PLP                                      pull processor status (SR)

    //  91 TAX                                      transfer accumulator to X
    //  92 TAY                                      transfer accumulator to Y
    //  94 TXA                                      transfer X to accumulator
    //  98 TYA                                      transfer Y to accumulator
    //  9D TSX                                      transfer stack pointer to X
    //  97 TXS                                      transfer X to stack pointer

    //  A0 BRK                                      break / interrupt
    //  A1 NOP                                      no operation

    //  B0 TRB                                      test and reset bits ( 65c02 )
    //  B1 BBRx                                     branch if bit x set ( 65c02 )
    //  B2 RMBx                                     reset bit x ( 65c02 )
    //  B8 TSB                                      test and set bits ( 65c02 )
    //  B9 BBSx                                     branch if bit x set ( 65c02 )
    //  BA SMBx                                     set bit x ( 65c02 )

    brom uint8 insn6502_to_mcode[] = {
        //  x0    x1    x2    x3    x4    x5    x6    x7    x8    x9    xa    xb    xc    xd    xe    xf
          8hA0, 8h05, 8h00, 8h00, 8hB8, 8h05, 8h06, 8h00, 8h84, 8h05, 8h70, 8h00, 8hB8, 8h05, 8h06, 8hB1,   // 0x
          8h17, 8h05, 8h05, 8h00, 8hB0, 8h05, 8h06, 8h00, 8h20, 8h05, 8h48, 8h00, 8hB0, 8h05, 8h06, 8hB1,   // 1x
          8h51, 8h03, 8h00, 8h00, 8h0A, 8h03, 8h08, 8h00, 8h8C, 8h03, 8h72, 8h00, 8h0A, 8h03, 8h08, 8hB1,   // 2x
          8h1F, 8h03, 8h00, 8h03, 8h0A, 8h03, 8h08, 8h00, 8h28, 8h03, 8h40, 8h00, 8h0A, 8h03, 8h08, 8hB1,   // 3x
          8h59, 8h04, 8h00, 8h00, 8h00, 8h04, 8h07, 8h00, 8h80, 8h04, 8h71, 8h00, 8h50, 8h04, 8h07, 8hB1,   // 4x
          8h16, 8h04, 8h04, 8h00, 8h00, 8h04, 8h07, 8h00, 8h22, 8h04, 8h82, 8h00, 8h00, 8h04, 8h07, 8hB1,   // 5x
          8h58, 8h01, 8h00, 8h00, 8h6F, 8h01, 8h09, 8h00, 8h88, 8h01, 8h73, 8h00, 8h50, 8h01, 8h09, 8hB1,   // 6x
          8h1E, 8h01, 8h01, 8h00, 8h6F, 8h01, 8h09, 8h00, 8h2A, 8h01, 8h8A, 8h00, 8h50, 8h01, 8h09, 8hB1,   // 7x
          8h15, 8h68, 8h00, 8h00, 8h6A, 8h68, 8h69, 8h00, 8h42, 8h0A, 8h94, 8h00, 8h6A, 8h68, 8h69, 8hB9,   // 8x
          8h10, 8h68, 8h68, 8h00, 8h6A, 8h68, 8h69, 8h00, 8h98, 8h68, 8h97, 8h00, 8h6F, 8h68, 8h6F, 8hB9,   // 9x
          8h62, 8h60, 8h61, 8h00, 8h62, 8h60, 8h61, 8h00, 8h92, 8h60, 8h91, 8h00, 8h62, 8h60, 8h61, 8hB9,   // Ax
          8h18, 8h60, 8h60, 8h00, 8h62, 8h60, 8h61, 8h00, 8h26, 8h60, 8h9D, 8h00, 8h62, 8h60, 8h61, 8hB9,   // Bx
          8h32, 8h30, 8h00, 8h00, 8h32, 8h30, 8h43, 8h00, 8h4A, 8h30, 8h41, 8h00, 8h32, 8h30, 8h43, 8hB9,   // Cx
          8h11, 8h30, 8h30, 8h00, 8h00, 8h30, 8h43, 8h00, 8h23, 8h30, 8h81, 8h00, 8h00, 8h30, 8h43, 8hB9,   // Dx
          8h31, 8h02, 8h00, 8h00, 8h32, 8h02, 8h4B, 8h00, 8h49, 8h02, 8h71, 8h00, 8h31, 8h02, 8h4B, 8hB9,   // Ex
          8h19, 8h02, 8h02, 8h00, 8h00, 8h02, 8h4B, 8h00, 8h28, 8h02, 8h89, 8h00, 8h00, 8h02, 8h4B, 8hB9    // Fx
    };

    // ADDRESSING MODES
    //  00 UNDEFINED
    //  01 ACCUMULATOR          OPC A               ( single byte instruction )
    //  02 ABSOLUTE             OPC $LLHH           operand is 16-bit address (requires fetching from)
    //  03 ABSOLUTE X INDEX     OPC $$LLHH,X        operand is address, effective address is +X with carry
    //  04 ABSOLUTE Y INDEX     OPC $$LLHH,Y        operand is address, effective address is +Y with carry
    //  05 BYTE IMMEDIATE       OPC $BB             operand is byte
    //  06 IMPLIED              OPC                 operand implied, RTS, RTI
    //  07 (IND)                OPC ($LLHH)         operand is address, effective address is contents of word at address
    //  08 X INDEX, (IND)       OPC ($LL,X)         operand is zeropage address, effective address is word in ( LL+X, LL+X+1 ) without carry
    //  09 IND, Y               OPC ($LL),Y         operand is zeropage address, effective address is word in ( LL, LL+1 ) incremented by Y with carry
    //  0A RELATIVE             OPC $BB             branch target is PC + signed offset BB
    //  0B ZEROPAGE             OPC $LL             operand is zeropage address
    //  0C ZEROPAGE X INDEX     OPC $LL,X           operand is zeropage address, effective address is address incremented by X without carry
    //  0D ZEROPAGE Y INDEX     OPC $LL,Y           operand is zeropage address, effective address is address incremented by Y without carry
    //  0E WORD IMMEDIATE       OPC $LLHH           operand is 16-bit address (for jmp, jsr, sta, stx, sty) (address is used, not fetched from)
    //  11 65c02 ZP (IND)       OPC ($LL)           operand is zeropage address, effective address is word in ( LL, LL+1 )
    //  12 65c02 X INDEX, (IND) OPC ($LLHH,X)       operand is address, effective address is word in ( LLHH+X, LLHH+X+1 ) without carry
    //  13 65c02 ZP, RELATIVE   OPC $LL,$BB         operand is zeropage address, branch target is PC + signed offset BB
    brom uint5 insn6502_to_amode[] = {
        //   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
          5h06, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h01, 5h00, 5h02, 5h02, 5h02, 5h12,                   // 0x
          5h0A, 5h09, 5h11, 5h00, 5h0B, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h02, 5h03, 5h03, 5h12,                   // 1x
          5h0E, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h01, 5h00, 5h02, 5h02, 5h02, 5h12,                   // 2x
          5h0A, 5h09, 5h11, 5h00, 5h0C, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h03, 5h03, 5h03, 5h12,                   // 3x
          5h06, 5h08, 5h00, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h01, 5h00, 5h0E, 5h02, 5h02, 5h12,                   // 4x
          5h0A, 5h09, 5h11, 5h00, 5h00, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h00, 5h03, 5h03, 5h12,                   // 5x
          5h06, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h01, 5h00, 5h07, 5h02, 5h02, 5h12,                   // 6x
          5h0A, 5h09, 5h11, 5h00, 5h0C, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h12, 5h03, 5h03, 5h12,                   // 7x
          5h0A, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h06, 5h00, 5h0E, 5h0E, 5h0E, 5h12,                   // 8x
          5h0A, 5h09, 5h11, 5h00, 5h0C, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h0E, 5h03, 5h03, 5h12,                   // 9x
          5h05, 5h08, 5h05, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h06, 5h00, 5h02, 5h02, 5h02, 5h12,                   // Ax
          5h0A, 5h09, 5h11, 5h00, 5h0C, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h03, 5h03, 5h03, 5h12,                   // Bx
          5h05, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h06, 5h00, 5h02, 5h02, 5h02, 5h12,                   // Cx
          5h0A, 5h09, 5h11, 5h00, 5h00, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h00, 5h03, 5h03, 5h12,                   // Dx
          5h05, 5h08, 5h00, 5h00, 5h0B, 5h0B, 5h0B, 5h0B, 5h06, 5h05, 5h06, 5h00, 5h02, 5h02, 5h02, 5h12,                   // Ex
          5h0A, 5h09, 5h11, 5h00, 5h00, 5h0C, 5h0C, 5h0B, 5h06, 5h04, 5h06, 5h00, 5h00, 5h03, 5h03, 5h12                    // Fx
    };

    // { change status, commit, store 16, store 8, multi-cycle, fetch 16, fetch 8 }
    brom uint7 mcode_actions[] = {
        //         01 ADC     02 SBC     03 AND     04 EOR     05 ORA     06 ASL     07 LSR     08 ROL     09 ROR     0A BIT
        7b0000000, 7b1100101, 7b1101101, 7b1100101, 7b1100101, 7b1100101, 7b1001001, 7b1001001, 7b1001001, 7b1001001, 7b1001001, 7b0000000, 7b0000000, 7b0000000, 7b0000000, 7b0000000,

        7b0000000,    //  10 BCC  branch on carry clear
        7b0000000,    //  11 BNE  branch on not equal (zero clear)
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,      //  15 BRA  branch ALWAYS ( 65c02 )
        7b0000000,    //  16 BVC  branch on overflow clear
        7b0000000,    //  17 BPL  branch on plus (negative clear)
        7b0000000,    //  18 BCS  branch on carry set
        7b0000000,    //  19 BEQ  branch on equal (zero set)
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,    //  1E BVS  branch on overflow set
        7b0000000,    //  1F BMI  branch on minus (negative set)

        7b1000000,    //  20 CLC  clear carry
        7b0000000,
        7b1000000,    //  22 CLI  clear interrupt disable
        7b1000000,    //  23 CLD  clear decimal
        7b0000000,
        7b0000000,
        7b1000000,    //  26 CLV  clear overflow
        7b0000000,
        7b1000000,    //  28 SEC  set carry
        7b0000000,
        7b1000000,    //  2A SEI  set interrupt disable
        7b1000000,    //  2B SED  set decimal
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b1000001,   //  30 CMP   compare (with accumulator)
        7b1000001,   //  31 CPX   compare with X
        7b1000001,   //  32 CPY    compare with Y
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b1100000,  //  40 DEC A                                    decrement A
        7b1100000,  //  41 DEX                                      decrement X
        7b1100000,  //  42 DEY                                      decrement Y
        7b1001101,  //  43 DEC                                      decrement
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b1100000,  //  48 INC A                                    increment A
        7b1100000,  //  49 INX                                      increment X
        7b1100000,  //  4A INY                                      increment Y
        7b1001101,  //  4B INC                                      increment
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b0000010,  //  50 JMP                                      jump
        7b0000110,  //  51 JSR                                      jump subroutine
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000100,  //  58 RTS                                      return from subroutine
        7b1000100,  //  59 RTI                                      return from interrupt
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b1100001,  //  60 LDA                                      load accumulator
        7b1100001,  //  61 LDX                                      load X
        7b1100001,  //  62 LDY                                      load Y
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0001000,  //  68 STA                                      store accumulator
        7b0001000,  //  69 STX                                      store X
        7b0001000,  //  6A STY                                      store Y
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0001000,  //  6F ST Z                                     store 0 ( 65c02 )

        7b1100000,  //  70 ASL A                                    arithmetic shift left
        7b1100000,  //  71 LSR A                                    logical shift right
        7b1100000,  //  72 ROL A                                    rotate left
        7b1100000,  //  73 ROR A                                    rotate right
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b0000100,    //  80 PHA                                      push accumulator
        7b0000100,  // 81   PHX
        7b0000100,  // 82   PHY
        7b0000000,
        7b0000100,   //  84 PHP                                      push processor status (SR)
        7b0000000,
        7b0000000,
        7b0000000,
        7b1100100,  //  88 PLA                                      pull accumulator
        7b1100100,  //  89 PLX
        7b1100100,  //  8A PLY
        7b0000000,
        7b1000100,  //  8C PLP                                      pull processor status (SR)
        7b0000000,
        7b0000000,
        7b0000000,

        7b0000000,    // 90
        7b1100000,  //  91 TAX                                      transfer accumulator to X
        7b1100000,  //  92 TAY                                      transfer accumulator to Y
        7b0000000,
        7b1100000,  //  94 TXA                                      transfer X to accumulator
        7b0000000,
        7b0000000,
        7b0100000,  //  97 TXS                                      transfer X to stack pointer
        7b1100000,  //  98 TYA                                      transfer Y to accumulator
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b1100000,  //  9D TSX                                      transfer stack pointer to X
        7b0000000,
        7b0000000,

        7b1000000,  //  A0 BRK                                      break / interrupt
        7b0000000,  //  A1 NOP                                      no operation
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,

        7b1001001,  //  B0 TRB                                      test and reset bits ( 65c02 )
        7b0000001,  //  B1 BBRx                                     branch if bit x clear ( 65c02 )
        7b0001001,  //  B2 RMBx                                     reset bit x ( 65c02 )
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b1001001,  //  B8 TSB                                      test and set bits ( 65c02 )
        7b0000001,  //  B9 BBSx                                     branch if bit x set ( 65c02 )
        7b0001001,  //  BA SMBx                                     set bit x ( 65c02 )
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000,
        7b0000000
    };

    brom uint2 insn6502_to_ilength[]  = {
        0, 1, 3, 3, 3, 2, 1, 3, 2, 2, 2, 2, 2, 2, 3, 0, 0,
        0, 2, 3, 3
    };

    insn6502_to_ilength.addr := insn6502_to_amode.rdata;
    mcode_actions.addr := insn6502_to_mcode.rdata;

    i_mcode := insn6502_to_mcode.rdata;
    i_amode := insn6502_to_amode.rdata;
    i_actions := mcode_actions.rdata;
    i_length := insn6502_to_ilength.rdata;

    i_indirect := 0; i_immediate := 0; i_ea := value_16; i_ea_offset := 0;

    algorithm <autorun> { while(1) {
        if( latch ) {
            insn6502_to_mcode.addr = fetch[0,8];
            insn6502_to_amode.addr = fetch[0,8];
            value_8 = fetch[8,8];
            value_16 = fetch[8,16];
        }

        switch( i_amode ) {
            default: {}
            case 5h03: { i_ea = value_16 + X; }                                                                                    // ABSOLUTE X INDEX
            case 5h04: { i_ea = value_16 + Y; }                                                                                    // ABSOLUTE Y INDEX
            case 5h05: { i_immediate = 1; }
            case 5h07: { i_ea = value_16; i_indirect = 1; }                                                                          // INDIRECT
            case 5h08: { i_ea = value_8 + X; i_indirect = 1; }                                                                       // ZP X INDEX INDIRECT
            case 5h09: { i_ea = value_8; i_indirect = 1; i_ea_offset = Y; }                                                               // ZP INDIRECT Y INDEX
            case 5h0A: { i_ea = PC + { {8{value_8[7,1]}}, value_8 }; }                                                             // BRANCH DESTINATION
            case 5h0B: { i_ea = value_8; }                                                                                         // ZERO PAGE ADDRESS
            case 5h0C: { i_ea = ( value_8 + X ) & 8hff; }                                                                          // ZERO PAGE X INDEX
            case 5h0D: { i_ea = ( value_8 + Y ) & 8hff; }                                                                          // ZERO PAGE Y INDEX
            case 5h11: { i_ea = value_8; i_indirect = 1; }                                                                      // ZP INDIRECT ( 65c02 )
            case 5h12: { i_ea = value_8; }                                                                                         // ZERO PAGE ADDRESS, RELATIVE ( 65c02 )
        }
    } }
}
