ca65 V2.18 - N/A
Main file   : SUPER8-MOS.s
Current file: SUPER8-MOS.s

000000r 1               ; HELP FROM https://github.com/chelsea6502/BeebEater/blob/main/BeebEater.asm
000000r 1               ; TO SET UP A SUFFICIENT BBC MOS TO SUPPORT BBC BASIC
000000r 1               
000000r 1               OSAREG =$00
000000r 1               OSXREG =$01
000000r 1               OSYREG =$02
000000r 1               OSINTA =$03
000000r 1               
000000r 1               .segment "STARTUP"
000000r 1  78           ENTRY:  sei                                                     ; mask interrupts
000001r 1  A2 FF                ldx #$ff                                                ; set stack pointer
000003r 1  9A                   txs
000004r 1               
000004r 1  A0 rr                ldy #<BOOTMSG
000006r 1  A9 rr                lda #>BOOTMSG
000008r 1  85 FE                sta $FE
00000Ar 1  84 FD                sty $FD
00000Cr 1  A0 00                ldy #0
00000Er 1               BOOTMSGLOOP:
00000Er 1  B1 FD                lda ($FD),y
000010r 1  20 rr rr             jsr PUTASCII
000013r 1  C8                   iny
000014r 1  C9 00                cmp #0
000016r 1  D0 F6                bne BOOTMSGLOOP
000018r 1               
000018r 1  18                   clc                                                     ; JUMP TO BBC BASIC
000019r 1  A9 01                lda #1
00001Br 1  58                   cli
00001Cr 1  4C 00 04             jmp $0400
00001Fr 1               
00001Fr 1               PUTASCII:                                                        ; OSWRCH: 'OS Write Character'
00001Fr 1                                                                               ; System call that displays whatever character is in A. This doesn't necessarily have to be an ASCII character.
00001Fr 1                                                                               ; The 'V' in "OSWRCHV" means "Vector". When BBC BASIC jumps to the OSWRCH address, it jumps straight to here.
00001Fr 1  8D 01 C0             sta $c001
000022r 1               
000022r 1  48                   pha
000023r 1               wait_term:
000023r 1  AD 01 D0             lda $d001
000026r 1  D0 FB                bne wait_term
000028r 1  68                   pla
000029r 1  8D 00 D0             sta $d000
00002Cr 1  60                   rts
00002Dr 1               
00002Dr 1               GETASCII:                                                        ; OSRDCH: 'OS Read Character'
00002Dr 1               readCharacterBuffer:
00002Dr 1  AD 02 C0             LDA  $C002
000030r 1  F0 FB                BEQ  readCharacterBuffer
000032r 1  AD 03 C0             LDA  $C003
000035r 1  60                   RTS
000036r 1               
000036r 1               ; Subroutine called after every NMI or IRQ in hardware, or the BRK instruction in software.
000036r 1               IRQV:
000036r 1  85 03            STA OSINTA ; Save A for later.
000038r 1  68               PLA ; Get the status register. IRQ/BRK puts it on the stack.
000039r 1  48               PHA ; Keep the status register on the stack for later.
00003Ar 1  29 10            AND #$10 ; Check if it's a BRK or an IRQ.
00003Cr 1  D0 03            BNE BRKV ; If it's BRK, that's an error. Go to the BRK vector.
00003Er 1               end_irq:
00003Er 1  A5 03            LDA OSINTA ; Restore A
000040r 1  40               RTI ; "ReTurn from Interrupt" Restore caller's flags, return to caller.
000041r 1               
000041r 1               ; -- BREAK Handler --
000041r 1               
000041r 1               ; Handler for interrupts that we know were called by the BRK instruction. This means an error was reported.
000041r 1               ; The BBC MOS API defines the structure of an error message. To get the message, we need to store the location of the error message in addresses $FD and $FE.
000041r 1               BRKV:
000041r 1  A5 03            LDA OSINTA ; Restore A
000043r 1  40               RTI ; "ReTurn from Interrupt" Restore caller's flags, return to caller.
000044r 1               
000044r 1               NMIV:
000044r 1  40               rti
000045r 1               
000045r 1                   ; Define the mapping from PS/2 Scancode to ASCII
000045r 1               keymap:
000045r 1  3F 3F 3F 3F      .byte "????????????? `?" ; 00-0F
000049r 1  3F 3F 3F 3F  
00004Dr 1  3F 3F 3F 3F  
000055r 1  3F 3F 3F 3F      .byte "?????q1???zsaw2?" ; 10-1F
000059r 1  3F 71 31 3F  
00005Dr 1  3F 3F 7A 73  
000065r 1  3F 63 78 64      .byte "?cxde43?? vftr5?" ; 20-2F
000069r 1  65 34 33 3F  
00006Dr 1  3F 20 76 66  
000075r 1  3F 6E 62 68      .byte "?nbhgy6???mju78?" ; 30-3F
000079r 1  67 79 36 3F  
00007Dr 1  3F 3F 6D 6A  
000085r 1  3F 2C 6B 69      .byte "?,kio09??./l;p-?" ; 40-4F
000089r 1  6F 30 39 3F  
00008Dr 1  3F 2E 2F 6C  
000095r 1  3F 3F 27 3F      .byte "??'?[=????",$0d,"]?\??" ; 50-5F
000099r 1  5B 3D 3F 3F  
00009Dr 1  3F 3F 0D 5D  
0000A5r 1  3F 3F 3F 3F      .byte "??????",$08,"??1?47???" ; 60-6F
0000A9r 1  3F 3F 08 3F  
0000ADr 1  3F 31 3F 34  
0000B5r 1  30 2E 32 35      .byte "0.2568",$1b,"??+3-*9??" ; 70-7F
0000B9r 1  36 38 1B 3F  
0000BDr 1  3F 2B 33 2D  
0000C5r 1               keymap_shifted:
0000C5r 1  3F 3F 3F 3F      .byte "????????????? ~?" ; 00-0F
0000C9r 1  3F 3F 3F 3F  
0000CDr 1  3F 3F 3F 3F  
0000D5r 1  3F 3F 3F 3F      .byte "?????Q!???ZSAW@?" ; 10-1F
0000D9r 1  3F 51 21 3F  
0000DDr 1  3F 3F 5A 53  
0000E5r 1  3F 43 58 44      .byte "?CXDE#$?? VFTR%?" ; 20-2F
0000E9r 1  45 23 24 3F  
0000EDr 1  3F 20 56 46  
0000F5r 1  3F 4E 42 48      .byte "?NBHGY^???MJU&*?" ; 30-3F
0000F9r 1  47 59 5E 3F  
0000FDr 1  3F 3F 4D 4A  
000105r 1  3F 3C 4B 49      .byte "?<KIO)(??>?L:P_?" ; 40-4F
000109r 1  4F 29 28 3F  
00010Dr 1  3F 3E 3F 4C  
000115r 1  3F 3F 22 3F      .byte "??",$22,"?{+?????}?|??" ; 50-5F
000119r 1  7B 2B 3F 3F  
00011Dr 1  3F 3F 3F 7D  
000125r 1  3F 3F 3F 3F      .byte "?????????1?47???" ; 60-6F
000129r 1  3F 3F 3F 3F  
00012Dr 1  3F 31 3F 34  
000135r 1  30 2E 32 35      .byte "0.2568???+3-*9??" ; 70-7F
000139r 1  36 38 3F 3F  
00013Dr 1  3F 2B 33 2D  
000145r 1               
000145r 1               
000145r 1               BOOTMSG:
000145r 1  0C 53 75 70      .byte   $0c, "Super8 ULX3s [2 x 65c02]", $0a, $0d, "32k RAM + 4k MOS ROM", $0a, $0d, $0a, $0d, "6502 TEST ROM", $0a, $0d, $07, $00
000149r 1  65 72 38 20  
00014Dr 1  55 4C 58 33  
000189r 1               
000189r 1               .segment "MOS_JMP"                                              ; Switch to SUPER8-MOS VECTORS
000000r 1  4C rr rr         jmp   PUTASCII                                            ; $FF00
000003r 1  4C rr rr         jmp   GETASCII                                            ; $FF03
000006r 1               
000006r 1               .segment "VECTORS"                                              ; Switch to 6502 CPU VECTORS @ FFFA
000000r 1  rr rr                .word   NMIV
000002r 1  00 04                .word   $0400
000004r 1  rr rr                .word   IRQV
000004r 1               
